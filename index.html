<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Background Effects Gallery — Ultra</title>
<style>
  :root{
    --bg:#000; --fg:#eaeaea; --accent:#9900FF;
    --panel-glass:rgba(255,255,255,.06); --border:rgba(255,255,255,.16);
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);
    font-family:-apple-system,BlinkMacSystemFont,"SF Pro Display","SF Pro Text","Helvetica Neue",Helvetica,Arial,sans-serif;overflow:hidden}
  canvas{position:fixed;inset:0;width:100%;height:100%;display:block}
  .legend{position:fixed;left:14px;top:14px;z-index:20;background:var(--panel-glass);backdrop-filter:blur(8px);
    border:1px solid var(--border);border-radius:14px;padding:10px 12px;max-width:min(92vw,520px);
    box-shadow:0 12px 32px rgba(0,0,0,.35);font-weight:700}
  .title{font-size:12px;opacity:.9}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-top:8px}
  .chip{display:flex;align-items:center;gap:8px;border:1px solid var(--border);padding:6px 10px;border-radius:999px;background:#00000033;cursor:pointer;user-select:none}
  .chip.active{outline:2px solid var(--accent);box-shadow:0 0 0 3px #ffffff10}
  .dot{width:12px;height:12px;border-radius:50%}
  .controls,.status{margin-top:8px;font-size:12px;opacity:.75}
  .accent{color:var(--accent)}
  #fx{z-index:0}
  /* WebGL fallback note */
  .warn{position:fixed;right:14px;top:14px;z-index:20;background:#1a1a1a;border:1px solid var(--border);border-radius:10px;padding:8px 10px;font-size:12px;display:none}
</style>
</head>
<body>
<canvas id="fx"></canvas>
<div class="warn" id="warn">WebGL disabled → shader effects auto-skip</div>

<div class="legend" id="legend">
  <div class="title">Background Effect: <span class="accent" id="effectName">Starfield</span></div>
  <div class="row" id="chips"></div>
  <div class="status">Auto-rotate: <span id="autoState">ON</span> • Every <span id="intervalMs">8,000</span> ms</div>
  <div class="controls">Controls: <b>Space/→</b> next • <b>←</b> prev • <b>A</b> auto • <b>R</b> random</div>
</div>

<script>
(function(){
  // Canvas / timing
  const cvs = document.getElementById('fx');
  const ctx2d = cvs.getContext('2d', { alpha: true });
  let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  let W, H, t = 0, raf;
  function resize(){
    W = cvs.width = Math.floor(innerWidth * DPR);
    H = cvs.height = Math.floor(innerHeight * DPR);
    cvs.style.width = innerWidth + 'px';
    cvs.style.height = innerHeight + 'px';
  }
  resize(); addEventListener('resize', resize);

  // Utility
  const R = (a,b)=> a + Math.random()*(b-a);
  const clamp = (x,a,b)=> Math.max(a, Math.min(b,x));
  const setAccent = hex => document.documentElement.style.setProperty('--accent', hex);

  // Effects registry
  // Each effect: { name, color, init(ctx2d|webgl), frame(ctx, dt, T), cleanup() }
  const FX = [];

  /* ------------------------- 0. Starfield ------------------------- */
  FX.push({
    name:'Starfield', color:'#9900FF',
    init(){
      this.ps = Array.from({length:160}, _=>({
        x:R(0,W), y:R(0,H), z:R(.2,1.2), vx:R(-.2,.2), vy:R(-.2,.2), r:R(.6,1.8), a:R(.35,.95)
      }));
      this.mx = W/2; this.my = H/2;
      this.mm = e=>{ this.mx=(e.clientX||innerWidth/2)*DPR; this.my=(e.clientY||innerHeight/2)*DPR; };
      addEventListener('pointermove', this.mm);
    },
    frame(){
      const c = ctx2d; c.clearRect(0,0,W,H);
      for (const p of this.ps){
        const dx=(this.mx-p.x)*0.0006, dy=(this.my-p.y)*0.0006;
        p.vx=(p.vx+dx)*0.985; p.vy=(p.vy+dy)*0.985;
        p.x+=p.vx + p.z*0.2; p.y+=p.vy + p.z*0.2;
        if(p.x<-10||p.x>W+10||p.y<-10||p.y>H+10){ p.x=R(0,W); p.y=R(0,H); p.vx=R(-.2,.2); p.vy=R(-.2,.2); }
        c.beginPath(); c.arc(p.x,p.y,p.r,0,Math.PI*2);
        c.fillStyle='rgba(153,0,255,'+p.a+')'; c.fill();
      }
    },
    cleanup(){ removeEventListener('pointermove', this.mm); }
  });

  /* ------------------------- 1. Matrix Rain ------------------------- */
  FX.push({
    name:'Matrix Rain', color:'#00FF88',
    init(){ this.cols = Math.ceil(W/(14*DPR)); this.y = Array(this.cols).fill(0);
            this.chars = 'アカサタナハマヤラワ0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; },
    frame(){
      const c=ctx2d; c.fillStyle='rgba(0,0,0,.08)'; c.fillRect(0,0,W,H);
      c.fillStyle=this.color; c.font=`${14*DPR}px monospace`;
      for(let i=0;i<this.cols;i++){
        const ch=this.chars[Math.floor(Math.random()*this.chars.length)];
        c.fillText(ch, i*14*DPR, this.y[i]*16*DPR);
        this.y[i] = (this.y[i]*16*DPR > H && Math.random()>0.975) ? 0 : this.y[i]+1;
      }
    }, cleanup(){} });

  /* ------------------------- 2. Aurora Waves ------------------------- */
  FX.push({
    name:'Aurora Waves', color:'#00E5FF',
    init(){}, frame(_,dt,T){
      const c=ctx2d; c.clearRect(0,0,W,H); c.globalCompositeOperation='lighter';
      for(let k=0;k<3;k++){
        const grad = c.createLinearGradient(0,0,W,H);
        const hue = ((T*0.03 + k*0.33)%1)*360;
        grad.addColorStop(0, `hsla(${hue},100%,60%,0.09)`);
        grad.addColorStop(1, `hsla(${(hue+120)%360},100%,60%,0.07)`);
        c.fillStyle=grad;
        const y=H*0.3+Math.sin(T*0.002+k)*H*0.1;
        c.beginPath(); c.moveTo(0,y);
        for(let x=0;x<=W;x+=20){ const yy=y+Math.sin(x*0.01+T*0.002+k)*40*DPR; c.lineTo(x,yy); }
        c.lineTo(W,H); c.lineTo(0,H); c.closePath(); c.fill();
      }
      c.globalCompositeOperation='source-over';
    }, cleanup(){} });

  /* ------------------------- 3. Plasma Bands ------------------------- */
  FX.push({
    name:'Plasma Bands', color:'#FFA500',
    init(){}, frame(_,dt,T){
      const c=ctx2d; c.clearRect(0,0,W,H);
      for(let i=0;i<8;i++){
        const off=T*0.001+i*0.4;
        const g=c.createRadialGradient(
          W*(0.5+0.35*Math.sin(off)), H*(0.5+0.35*Math.cos(off)), 10,
          W*(0.5+0.35*Math.cos(off*0.7)), H*(0.5+0.35*Math.sin(off*0.8)), Math.max(W,H)
        );
        g.addColorStop(0, `hsla(${(off*180)%360},100%,55%,0.10)`);
        g.addColorStop(1, `hsla(${(off*180+120)%360},100%,55%,0.02)`);
        c.fillStyle=g; c.fillRect(0,0,W,H);
      }
    }, cleanup(){} });

  /* ------------------------- 4. Metaballs ------------------------- */
  FX.push({
    name:'Metaballs', color:'#00FFFF',
    init(){ const n=10; this.b=[];
      for(let i=0;i<n;i++) this.b.push({x:R(0,W),y:R(0,H),r:R(20*DPR,80*DPR),vx:R(-1,1),vy:R(-1,1),c:`hsla(${R(180,220)},100%,60%,0.4)`});
    },
    frame(){ const c=ctx2d; c.clearRect(0,0,W,H); c.globalCompositeOperation='lighter';
      for(const m of this.b){
        m.x+=m.vx; m.y+=m.vy; if(m.x<m.r||m.x>W-m.r) m.vx*=-1; if(m.y<m.r||m.y>H-m.r) m.vy*=-1;
        const g=c.createRadialGradient(m.x,m.y,1,m.x,m.y,m.r);
        g.addColorStop(0,m.c); g.addColorStop(1,'rgba(0,0,0,0)'); c.fillStyle=g; c.beginPath(); c.arc(m.x,m.y,m.r,0,Math.PI*2); c.fill();
      } c.globalCompositeOperation='source-over';
    }, cleanup(){} });

  /* ------------------------- 5. Confetti ------------------------- */
  FX.push({
    name:'Confetti', color:'#FFD166',
    init(){ this.items=Array.from({length:180},_=>({x:R(0,W),y:R(-H,0),s:R(4*DPR,10*DPR),vy:R(0.5,2.2),rot:R(0,6.28),vr:R(-0.05,0.05),c:`hsl(${Math.floor(R(0,360))},100%,60%)`})); },
    frame(){ const c=ctx2d; c.clearRect(0,0,W,H);
      for(const p of this.items){ p.y+=p.vy; p.rot+=p.vr; if(p.y>H+20){p.y=-20;p.x=R(0,W);}
        c.save(); c.translate(p.x,p.y); c.rotate(p.rot); c.fillStyle=p.c; c.fillRect(-p.s/2,-p.s/2,p.s,p.s); c.restore(); }
    }, cleanup(){} });

  /* ------------------------- 6. Hex Pulse ------------------------- */
  FX.push({
    name:'Hex Pulse', color:'#4DA3FF',
    init(){}, frame(_,dt,T){
      const c=ctx2d; c.clearRect(0,0,W,H);
      const size=28*DPR, w=Math.ceil(W/(size*1.5))+2, h=Math.ceil(H/(size*Math.sqrt(3)))+2;
      for(let j=0;j<h;j++) for(let i=0;i<w;i++){
        const x=i*size*1.5 + (j%2? size*0.75:0), y=j*size*Math.sqrt(3)/2;
        const puls=(Math.sin((x+y)*0.01+T*0.003)+1)/2;
        const col=`hsla(${200+60*puls},100%,${40+20*puls}%,${0.25+0.15*puls})`;
        drawHex(x,y,size*0.9,col);
      }
      function drawHex(cx,cy,r,fill){ const c=ctx2d; c.beginPath();
        for(let k=0;k<6;k++){const a=Math.PI/3*k,px=cx+r*Math.cos(a),py=cy+r*Math.sin(a); k?c.lineTo(px,py):c.moveTo(px,py);}
        c.closePath(); c.fillStyle=fill; c.fill();
      }
    }, cleanup(){} });

  /* ------------------------- 7. Low-Poly Triangles ------------------------- */
  FX.push({
    name:'Low-Poly Triangles', color:'#FF66CC',
    init(){ this.pts=[]; const step=90*DPR;
      for(let y=0;y<=H;y+=step) for(let x=0;x<=W;x+=step) this.pts.push({x:x+R(-25,25),y:y+R(-25,25)});
      this.tris=[]; const cols=Math.floor(W/step)+1, rows=Math.floor(H/step)+1;
      for(let j=0;j<rows-1;j++) for(let i=0;i<cols-1;i++){ const p0=j*cols+i,p1=p0+1,p2=p0+cols,p3=p2+1; this.tris.push([p0,p2,p1]); this.tris.push([p1,p2,p3]); }
    },
    frame(_,dt,T){ const c=ctx2d; c.clearRect(0,0,W,H);
      for(const tri of this.tris){
        const p=tri.map(i=>this.pts[i]); const hue=((p[0].x+p[0].y+T*0.05)%720)/2;
        c.beginPath(); c.moveTo(p[0].x,p[0].y); c.lineTo(p[1].x,p[1].y); c.lineTo(p[2].x,p[2].y); c.closePath();
        c.fillStyle=`hsla(${hue},80%,40%,0.35)`; c.fill();
        for(const q of p){ q.x+=Math.sin((q.x+T)*0.0007)*0.15; q.y+=Math.cos((q.y-T)*0.0007)*0.15; }
      }
    }, cleanup(){} });

  /* ------------------------- 8. Flow Field ------------------------- */
  FX.push({
    name:'Flow Field', color:'#7C4DFF',
    init(){ this.noise = makePerlin(); this.ps = Array.from({length:800}, _=>({x:R(0,W),y:R(0,H)})); },
    frame(_,dt,T){ const c=ctx2d; c.fillStyle='rgba(0,0,0,0.07)'; c.fillRect(0,0,W,H);
      c.strokeStyle=this.color; c.lineWidth=1*DPR; c.beginPath();
      for(const p of this.ps){
        const a = this.noise.noise((p.x+T*0.05)/250,(p.y-T*0.02)/250, T*0.0002)*Math.PI*2;
        p.x += Math.cos(a)*1.2; p.y += Math.sin(a)*1.2;
        if(p.x<0)p.x=W; if(p.x>W)p.x=0; if(p.y<0)p.y=H; if(p.y>H)p.y=0;
        c.moveTo(p.x,p.y); c.lineTo(p.x+0.001,p.y+0.001);
      } c.stroke();
    }, cleanup(){} });

  /* ------------------------- 9. Boids ------------------------- */
  FX.push({
    name:'Boids', color:'#00D4FF',
    init(){ this.b=Array.from({length:120},_=>({x:R(0,W),y:R(0,H),vx:R(-1,1),vy:R(-1,1)})); },
    frame(){ const b=this.b, c=ctx2d; c.fillStyle='rgba(0,0,0,.1)'; c.fillRect(0,0,W,H);
      const align=0.05, coh=0.0005, sep=0.02, view=60*DPR;
      for(let i=0;i<b.length;i++){
        let vx=0,vy=0, cx=0,cy=0, cnt=0, sx=0,sy=0;
        for(let j=0;j<b.length;j++) if(i!==j){ const dx=b[j].x-b[i].x, dy=b[j].y-b[i].y, d=Math.hypot(dx,dy);
          if(d<view){ vx+=b[j].vx; vy+=b[j].vy; cx+=b[j].x; cy+=b[j].y; cnt++; if(d<20*DPR){ sx-=dx; sy-=dy; } } }
        if(cnt){ b[i].vx+=(vx/cnt - b[i].vx)*align + (cx/cnt - b[i].x)*coh + sx*sep;
                 b[i].vy+=(vy/cnt - b[i].vy)*align + (cy/cnt - b[i].y)*coh + sy*sep; }
        const sp=2.2; const s=Math.hypot(b[i].vx,b[i].vy); if(s>sp){ b[i].vx*=sp/s; b[i].vy*=sp/s; }
        b[i].x=(b[i].x+b[i].vx+W)%W; b[i].y=(b[i].y+b[i].vy+H)%H;
      }
      c.fillStyle=this.color; for(const a of b){ c.beginPath(); c.arc(a.x,a.y,2.2*DPR,0,6.283); c.fill(); }
    }, cleanup(){} });

  /* -------------------------10. Perlin Clouds ------------------------- */
  FX.push({
    name:'Perlin Clouds', color:'#66CCFF',
    init(){ this.p = makePerlin(); this.off = Math.random()*1000; this.tmp = ctx2d.createImageData(Math.floor(W/3), Math.floor(H/3)); },
    frame(){ const id=this.tmp, p=this.p, w=id.width, h=id.height, data=id.data, t=this.off + performance.now()*0.00015;
      for(let y=0;y<h;y++) for(let x=0;x<w;x++){
        const n = p.noise(x/120, y/120, t)*0.5+0.5;
        const i=(y*w+x)*4; data[i]=data[i+1]=data[i+2]=Math.floor(255*n); data[i+3]=255;
      }
      ctx2d.imageSmoothingEnabled=true; ctx2d.putImageData(id,0,0); ctx2d.drawImage(cvs,0,0,w,h,0,0,W,H);
      ctx2d.globalCompositeOperation='lighter'; ctx2d.fillStyle='rgba(102,204,255,0.05)'; ctx2d.fillRect(0,0,W,H); ctx2d.globalCompositeOperation='source-over';
    }, cleanup(){} });

  /* -------------------------11. Voronoi Cells (Worley-ish) ------------------------- */
  FX.push({
    name:'Voronoi Cells', color:'#FF7A7A',
    init(){ this.pts=Array.from({length:40},_=>({x:R(0,W),y:R(0,H)})); this.buf=ctx2d.createImageData(Math.floor(W/4),Math.floor(H/4)); },
    frame(){ const w=this.buf.width,h=this.buf.height,d=this.buf.data;
      for(let y=0;y<h;y++) for(let x=0;x<w;x++){
        let d1=1e9,d2=1e9; const X=x*4*DPR, Y=y*4*DPR;
        for(const p of this.pts){ const dx=X-p.x, dy=Y-p.y, dd=dx*dx+dy*dy; if(dd<d1){d2=d1;d1=dd;} else if(dd<d2){d2=dd;} }
        const v = Math.sqrt(d2)-Math.sqrt(d1); // edge intensity
        const g = clamp(200- v*0.08, 20, 220);
        const i=(y*w+x)*4; d[i]=g; d[i+1]=Math.floor(g*0.6); d[i+2]=Math.floor(g*0.8); d[i+3]=255;
      }
      ctx2d.putImageData(this.buf,0,0); ctx2d.drawImage(cvs,0,0,w,h,0,0,W,H);
    }, cleanup(){} });

  /* -------------------------12. Shader Ripple (WebGL) ------------------------- */
  FX.push({
    name:'Shader Ripple', color:'#66EEFF',
    init(){
      const gl = this.gl = cvs.getContext('webgl');
      if(!gl){ document.getElementById('warn').style.display='block'; this.disabled=true; return; }
      document.getElementById('warn').style.display='none';
      const vs = `
        attribute vec2 p; void main(){ gl_Position=vec4(p,0.0,1.0); }
      `;
      const fs = `
        precision highp float;
        uniform vec2 res; uniform float time;
        void main(){
          vec2 uv = (gl_FragCoord.xy/res)*2.0-1.0;
          uv.x *= res.x/res.y;
          float d = length(uv);
          float w = 0.5 + 0.5*sin(14.0*d - time*2.2);
          float c = 0.65 + 0.35*cos(8.0*(uv.x+uv.y) + time*1.4);
          vec3 col = mix(vec3(0.0), vec3(0.2,0.9,1.0), w) * c;
          gl_FragColor = vec4(col,1.0);
        }
      `;
      const prg = gl.createProgram();
      const sh = (type,src)=>{ const s=gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s); return s; };
      gl.attachShader(prg, sh(gl.VERTEX_SHADER, vs));
      gl.attachShader(prg, sh(gl.FRAGMENT_SHADER, fs));
      gl.linkProgram(prg); gl.useProgram(prg);
      const buf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buf);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);
      const loc = gl.getAttribLocation(prg,'p'); gl.enableVertexAttribArray(loc); gl.vertexAttribPointer(loc,2,gl.FLOAT,false,0,0);
      this.uRes = gl.getUniformLocation(prg,'res'); this.uTime = gl.getUniformLocation(prg,'time'); this.prg=prg;
    },
    frame(_,dt,T){
      if(this.disabled) return; const gl=this.gl;
      gl.viewport(0,0,W,H); gl.clearColor(0,0,0,1); gl.clear(gl.COLOR_BUFFER_BIT);
      gl.useProgram(this.prg); gl.uniform2f(this.uRes, W, H); gl.uniform1f(this.uTime, T*0.001);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    },
    cleanup(){ if(this.gl){ /* no-op */ } }
  });

  /* -------------------------13. Feedback Trails ------------------------- */
  FX.push({
    name:'Feedback Trails', color:'#FF55AA',
    init(){ this.x=W/2; this.y=H/2; this.t=0; },
    frame(_,dt,T){ const c=ctx2d;
      c.save(); c.globalAlpha=0.9; c.drawImage(cvs,0,0); c.restore(); // frame echo
      this.t += 0.03; this.x = W/2 + Math.cos(T*0.0013)*W*0.25; this.y = H/2 + Math.sin(T*0.0017)*H*0.25;
      c.fillStyle='rgba(255,85,170,0.5)'; c.beginPath(); c.arc(this.x,this.y,12*DPR,0,6.283); c.fill();
      // subtle scale to create smear
      c.setTransform(1.002,0,0,1.002,-W*0.001,-H*0.001);
    }, cleanup(){ ctx2d.setTransform(1,0,0,1,0,0); }
  });

  /* -------------------------14. Wave Interference ------------------------- */
  FX.push({
    name:'Wave Interference', color:'#9D7CFF',
    init(){}, frame(_,dt,T){
      const c=ctx2d; c.clearRect(0,0,W,H);
      const k1 = 0.008, k2 = 0.011;
      for(let y=0;y<H;y+=3){ for(let x=0;x<W;x+=3){
        const v = Math.sin(x*k1 + T*0.002) + Math.sin((x+y)*k2 - T*0.0017);
        const m = Math.floor(140 + 60 * Math.sin(v));
        c.fillStyle = `rgba(${m},${m+20},${255-m},0.45)`; c.fillRect(x,y,3,3);
      } }
    }, cleanup(){} });

  /* -------------------------15. Particle Explosions ------------------------- */
  FX.push({
    name:'Particle Explosions', color:'#FF6B6B',
    init(){ this.ps=[]; this.spawn(); this.click=e=>this.spawn((e.clientX||W/2)*DPR,(e.clientY||H/2)*DPR); addEventListener('click',this.click); },
    spawn(x=R(W*0.2,W*0.8), y=R(H*0.2,H*0.8)){ for(let i=0;i<180;i++) this.ps.push({x,y, vx:R(-3,3), vy:R(-3,3), a:1}); },
    frame(){ const c=ctx2d; c.fillStyle='rgba(0,0,0,0.1)'; c.fillRect(0,0,W,H); c.globalCompositeOperation='lighter';
      this.ps.forEach(p=>{ p.x+=p.vx; p.y+=p.vy; p.vx*=0.985; p.vy*=0.985; p.a*=0.97;
        c.fillStyle=`rgba(255,107,107,${p.a})`; c.beginPath(); c.arc(p.x,p.y,2.5*DPR,0,6.283); c.fill();
      }); this.ps=this.ps.filter(p=>p.a>0.05); c.globalCompositeOperation='source-over';
      if(this.ps.length<40) this.spawn();
    }, cleanup(){ removeEventListener('click',this.click); } });

  /* -------------------------16. Glitch Scanlines ------------------------- */
  FX.push({
    name:'Glitch', color:'#A0FFE6',
    init(){}, frame(){ const c=ctx2d;
      c.fillStyle='rgba(0,0,0,0.08)'; c.fillRect(0,0,W,H);
      // random bars
      for(let i=0;i<6;i++){ const y=R(0,H), h=R(2*DPR, 10*DPR), xoff=R(-30*DPR,30*DPR);
        c.fillStyle=`rgba(160,255,230,${R(0.15,0.35)})`; c.fillRect(0,y,W,h);
        c.globalCompositeOperation='lighter'; c.fillRect(xoff,y,W,h); c.globalCompositeOperation='source-over';
      }
      // RGB split noise
      for(let i=0;i<200;i++){ c.fillStyle=`rgba(${R(150,255)},${R(150,255)},${R(150,255)},${R(0.02,0.08)})`; c.fillRect(R(0,W),R(0,H),2,2); }
    }, cleanup(){} });

  /* -------------------------17. L-System Trees ------------------------- */
  FX.push({
    name:'L-System Trees', color:'#66FF66',
    init(){ this.iter=0; this.maxIter=5; this.axiom='F'; this.rules={ 'F':'F[+F]F[-F]F' };
      this.angle=25*Math.PI/180; this.len=Math.min(W,H)*0.05; },
    frame(_,dt,T){
      const c=ctx2d; c.clearRect(0,0,W,H);
      let str=this.axiom; for(let i=0;i<this.iter;i++){ let next=''; for(const ch of str) next += this.rules[ch]||ch; str=next; }
      c.save(); c.translate(W/2,H*0.95); c.strokeStyle=this.color; c.globalAlpha=0.9; c.lineWidth=1.4*DPR;
      const stack=[]; let len=this.len*Math.pow(0.76,this.iter);
      for(const ch of str){
        if(ch==='F'){ c.beginPath(); c.moveTo(0,0); c.lineTo(0,-len); c.stroke(); c.translate(0,-len); }
        else if(ch=== '+'){ c.rotate(this.angle); }
        else if(ch=== '-'){ c.rotate(-this.angle); }
        else if(ch==='['){ stack.push([c.getTransform(), len]); len*=0.82; }
        else if(ch===']'){ const s=stack.pop(); c.setTransform(s[0]); c.translate(0,0); len=s[1]; }
      }
      c.restore();
      this.iter = 1 + Math.floor( (Math.sin(T*0.0012)+1)*0.5 * this.maxIter );
    }, cleanup(){} });

  /* -------------------------18. 3D Points (pseudo) ------------------------- */
  FX.push({
    name:'3D Points', color:'#55CCFF',
    init(){ this.pts=[]; for(let i=0;i<1200;i++){ // sphere-ish cloud
        const u=Math.random(), v=Math.random();
        const theta=2*Math.PI*u, phi=Math.acos(2*v-1);
        const r=R(0.2,1)*Math.min(W,H)*0.4;
        this.pts.push([r*Math.sin(phi)*Math.cos(theta), r*Math.sin(phi)*Math.sin(theta), r*Math.cos(phi)]);
      } },
    frame(_,dt,T){ const c=ctx2d; c.clearRect(0,0,W,H);
      const a=T*0.0004, b=T*0.0006; const cosA=Math.cos(a), sinA=Math.sin(a), cosB=Math.cos(b), sinB=Math.sin(b);
      c.fillStyle=this.color;
      for(const p of this.pts){
        // rotate around Y and X
        let x=p[0]*cosA + p[2]*sinA, z=-p[0]*sinA + p[2]*cosA;
        let y=p[1]*cosB - z*sinB; z=p[1]*sinB + z*cosB;
        const d= 300*DPR/(300+z); const sx=W/2+x*d, sy=H/2+y*d;
        const r = Math.max(1, 1.5*DPR*d*0.6);
        c.globalAlpha = clamp(0.2 + (z / (Math.min(W,H)*0.5))*0.8, 0.15, 1);
        c.beginPath(); c.arc(sx,sy,r,0,6.283); c.fill();
      } c.globalAlpha=1;
    }, cleanup(){} });

  /* -------------------------19. Game of Life ------------------------- */
  FX.push({
    name:"Game of Life", color:'#FFFFFF',
    init(){ this.scale=4; this.w=Math.floor(W/(this.scale*DPR)); this.h=Math.floor(H/(this.scale*DPR));
      this.a=new Uint8Array(this.w*this.h); this.b=new Uint8Array(this.w*this.h);
      for(let i=0;i<this.a.length;i++) this.a[i] = Math.random()<0.16?1:0;
    },
    frame(){ const w=this.w,h=this.h,a=this.a,b=this.b; const c=ctx2d;
      for(let y=0;y<h;y++) for(let x=0;x<w;x++){
        let n=0; for(let yy=-1;yy<=1;yy++) for(let xx=-1;xx<=1;xx++) if(xx||yy){
          const X=(x+xx+w)%w, Y=(y+yy+h)%h; n+=a[Y*w+X]; }
        const idx=y*w+x; b[idx] = (n===3 || (n===2 && a[idx])) ? 1 : 0;
      }
      // draw
      c.clearRect(0,0,W,H); c.fillStyle='#ffffff'; for(let y=0;y<h;y++) for(let x=0;x<w;x++)
        if(b[y*w+x]) c.fillRect(x*this.scale*DPR,y*this.scale*DPR,this.scale*DPR,this.scale*DPR);
      // swap
      this.a.set(b);
    }, cleanup(){} });

  /* -------------------------20. Reaction–Diffusion (Gray–Scott) ------------------------- */
  FX.push({
    name:'Reaction–Diffusion', color:'#99FFDD',
    init(){
      this.s=2; // low-res grid upscale
      this.w=Math.floor(W/(this.s*DPR)); this.h=Math.floor(H/(this.s*DPR));
      this.U=new Float32Array(this.w*this.h).fill(1); this.V=new Float32Array(this.w*this.h).fill(0);
      // seed
      for(let y=this.h/2-10;y<this.h/2+10;y++) for(let x=this.w/2-10;x<this.w/2+10;x++) this.V[y*this.w+x]=1;
      this.Du=0.16; this.Dv=0.08; this.f=0.060; this.k=0.062;
      this.tmpU=new Float32Array(this.U); this.tmpV=new Float32Array(this.V);
    },
    frame(){ const w=this.w,h=this.h, U=this.U, V=this.V, nU=this.tmpU, nV=this.tmpV;
      // iterate a few steps
      for(let iter=0;iter<8;iter++){
        for(let y=1;y<h-1;y++) for(let x=1;x<w-1;x++){
          const i=y*w+x;
          const lapU = U[i-1]+U[i+1]+U[i-w]+U[i+w]-4*U[i];
          const lapV = V[i-1]+V[i+1]+V[i-w]+V[i+w]-4*V[i];
          const uvv = U[i]*V[i]*V[i];
          nU[i] = U[i] + (this.Du*lapU - uvv + this.f*(1-U[i]))*1.0;
          nV[i] = V[i] + (this.Dv*lapV + uvv - (this.f+this.k)*V[i])*1.0;
        }
        [this.U,this.tmpU] = [nU,U]; [this.V,this.tmpV] = [nV,V];
      }
      // render
      const c=ctx2d; const scale=this.s*DPR;
      for(let y=0;y<h;y++) for(let x=0;x<w;x++){
        const i=y*w+x, v=this.V[i]; const g=clamp(Math.floor((v)*255),0,255);
        c.fillStyle=`rgba(${g},${255-g},${220},0.9)`; c.fillRect(x*scale,y*scale,scale,scale);
      }
    }, cleanup(){} });

  /* -------------------------21. Lens Distortion (magnifier) ------------------------- */
  FX.push({
    name:'Lens Distortion', color:'#FFB300',
    init(){ this.off = ctx2d.createLinearGradient(0,0,W,H); this.off.addColorStop(0,'#0a0a0a'); this.off.addColorStop(1,'#222');
      this.mx=W/2; this.my=H/2; this.mm=e=>{this.mx=(e.clientX||innerWidth/2)*DPR; this.my=(e.clientY||innerHeight/2)*DPR;}; addEventListener('pointermove',this.mm);
      // create a background texture to distort (simple soft grid)
      this.bg = document.createElement('canvas'); this.bg.width=W; this.bg.height=H; const g=this.bg.getContext('2d');
      g.fillStyle=this.off; g.fillRect(0,0,W,H);
      g.strokeStyle='rgba(255,255,255,0.04)'; for(let x=0;x<W;x+=40*DPR){ g.beginPath(); g.moveTo(x,0); g.lineTo(x,H); g.stroke(); }
      for(let y=0;y<H;y+=40*DPR){ g.beginPath(); g.moveTo(0,y); g.lineTo(W,y); g.stroke(); }
    },
    frame(){ const c=ctx2d; c.clearRect(0,0,W,H); c.drawImage(this.bg,0,0);
      const r=120*DPR; c.save(); c.beginPath(); c.arc(this.mx,this.my,r,0,6.283); c.clip();
      // magnify under the lens
      c.drawImage(this.bg, this.mx-r, this.my-r, r*2, r*2, this.mx-r*1.2, this.my-r*1.2, r*2*1.2, r*2*1.2);
      c.restore();
      c.strokeStyle=this.color; c.lineWidth=2*DPR; c.beginPath(); c.arc(this.mx,this.my,r,0,6.283); c.stroke();
    },
    cleanup(){ removeEventListener('pointermove', this.mm); }
  });

  /* -------------------------22. Shader Kaleidoscope (WebGL) ------------------------- */
  FX.push({
    name:'Shader Kaleidoscope', color:'#FF77FF',
    init(){
      const gl = this.gl = cvs.getContext('webgl');
      if(!gl){ document.getElementById('warn').style.display='block'; this.disabled=true; return; }
      document.getElementById('warn').style.display='none';
      const vs=`attribute vec2 p;void main(){gl_Position=vec4(p,0.,1.);} `;
      const fs=`precision highp float;uniform vec2 res;uniform float time;
        vec2 rot(vec2 v,float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c)*v;}
        void main(){
          vec2 uv=(gl_FragCoord.xy/res)*2.-1.; uv.x*=res.x/res.y;
          float t=time*0.3;
          uv=rot(uv, t*0.2);
          float ang=atan(uv.y,uv.x); float rad=length(uv);
          float seg=6.0; ang=abs(mod(ang, 6.28318/seg)-3.14159/seg);
          float v=sin(10.0*rad - time*1.2 + ang*6.0);
          vec3 col=0.5+0.5*cos(vec3(0.,2.1,3.7)+v+time*0.4);
          gl_FragColor=vec4(col,1.0);
        }`;
      const prog=gl.createProgram();
      function sh(type,src){const s=gl.createShader(type);gl.shaderSource(s,src);gl.compileShader(s);return s;}
      gl.attachShader(prog, sh(gl.VERTEX_SHADER,vs)); gl.attachShader(prog, sh(gl.FRAGMENT_SHADER,fs)); gl.linkProgram(prog); gl.useProgram(prog);
      const buf=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,buf);
      gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([-1,-1, 1,-1, -1,1, 1,1]),gl.STATIC_DRAW);
      const loc=gl.getAttribLocation(prog,'p'); gl.enableVertexAttribArray(loc); gl.vertexAttribPointer(loc,2,gl.FLOAT,false,0,0);
      this.uRes=gl.getUniformLocation(prog,'res'); this.uTime=gl.getUniformLocation(prog,'time'); this.prog=prog;
    },
    frame(_,dt,T){ if(this.disabled) return; const gl=this.gl;
      gl.viewport(0,0,W,H); gl.useProgram(this.prog); gl.uniform2f(this.uRes,W,H); gl.uniform1f(this.uTime,T*0.001); gl.drawArrays(gl.TRIANGLE_STRIP,0,4);
    }, cleanup(){ }
  });

  // ---------- Engine & UI ----------
  const chipsWrap = document.getElementById('chips');
  let idx = 0, last = performance.now(), auto = true, interval = 8000, timer;

  function renderChips(){
    chipsWrap.innerHTML='';
    FX.forEach((fx,i)=>{
      const chip=document.createElement('div');
      chip.className='chip'+(i===idx?' active':'');
      chip.innerHTML=`<span class="dot" style="background:${fx.color}"></span><span>${fx.name}</span>`;
      chip.onclick=()=>start(i);
      chipsWrap.appendChild(chip);
    });
    document.getElementById('autoState').textContent = auto?'ON':'OFF';
    document.getElementById('intervalMs').textContent = interval.toLocaleString();
    document.getElementById('effectName').textContent = FX[idx].name;
  }

  function start(i){
    if(i<0) i=FX.length-1; if(i>=FX.length) i=0;
    FX[idx] && FX[idx].cleanup && FX[idx].cleanup();
    idx=i; setAccent(FX[idx].color);
    renderChips();
    FX[idx].init && FX[idx].init(ctx2d);
    last=performance.now();
    if(auto){ clearTimeout(timer); timer=setTimeout(()=>start(idx+1), interval); }
  }

  function loop(now){
    const dt=now-last; last=now; t+=dt;
    FX[idx].frame && FX[idx].frame(ctx2d, dt, t);
    raf=requestAnimationFrame(loop);
  }

  addEventListener('keydown', e=>{
    if(e.key===' '||e.key==='ArrowRight'){ e.preventDefault(); start(idx+1); }
    else if(e.key==='ArrowLeft'){ start(idx-1); }
    else if(e.key.toLowerCase()==='a'){ auto=!auto; renderChips(); if(auto) start(idx); else clearTimeout(timer); }
    else if(e.key.toLowerCase()==='r'){ start(Math.floor(Math.random()*FX.length)); }
  });

  start(0);
  raf=requestAnimationFrame(loop);

  // -------- Perlin noise (simple) --------
  function makePerlin(){
    const p=new Uint8Array(512); for(let i=0;i<256;i++) p[i]=i; for(let i=0;i<256;i++){ const j=(Math.random()*256)|0; [p[i],p[j]]=[p[j],p[i]]; } for(let i=0;i<256;i++) p[i+256]=p[i];
    const g=new Array(512); for(let i=0;i<512;i++){ const a=Math.random()*Math.PI*2; g[i]=[Math.cos(a),Math.sin(a)]; }
    function fade(t){return t*t*t*(t*(t*6-15)+10);}
    function lerp(a,b,t){return a+(b-a)*t;}
    function dot(h, x, y){return h[0]*x + h[1]*y;}
    return {
      noise(x,y,z){
        const X=Math.floor(x)&255, Y=Math.floor(y)&255; x-=Math.floor(x); y-=Math.floor(y);
        const u=fade(x), v=fade(y);
        const aa=p[p[X]+Y], ab=p[p[X]+Y+1], ba=p[p[X+1]+Y], bb=p[p[X+1]+Y+1];
        const x1=lerp(dot(g[aa], x , y ), dot(g[ba], x-1, y ), u);
        const x2=lerp(dot(g[ab], x , y-1 ), dot(g[bb], x-1, y-1 ), u);
        return lerp(x1,x2,v);
      }
    };
  }
})();
</script>
</body>
</html>
